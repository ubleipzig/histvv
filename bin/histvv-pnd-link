#!/usr/bin/perl

use strict;
use warnings;

use Histvv;
use Histvv::CLI;
use XML::LibXML;
use XML::LibXML::XPathContext;
use DBI;
use URI;
use URI::Escape;
use LWP::UserAgent;
use File::Temp;

my $cli = Histvv::CLI->new(with_debug => 1);
my %opts = $cli->get_opts(
    'list|l'    => 0,
    'prepend|p' => 0,
    'offline'   => 0,
    'out|o=s'   => undef,
    'cache|c=s' => undef,
    'ttl|t=f'   => 24 * 60,
    'delay|D=i' => 20,
    'urlescape|E' => 0,
    'noreplace|R' => 0,
    'passthru|P' => 0,
    'follow-refresh' => 0
);

my $dozenten = shift or $cli->error( 'Please specify path to dozenten.xml!' );
my $beacon = shift or $cli->error( 'Please specify path to beacon file!' );

$cli->error("To work offline you need to specify a link cache database!")
  if $opts{offline} && ! $opts{cache};

my (%pnd, %dozenten, $url_template, $dbh, $sth_select, $sth_insert);

my $ttl = $opts{ttl} * 60;

my $sql_create = <<EOT;
CREATE TABLE link (
  target TEXT PRIMARY KEY,
  pnd TEXT NOT NULL,
  url TEXT NOT NULL,
  time TEXT DEFAULT (datetime('now'))
)
EOT

my $sql_select = <<EOT;
SELECT url, strftime('%s', 'now') - strftime('%s', time) age
FROM link WHERE target = ?
EOT

my $sql_insert = <<EOT;
INSERT OR REPLACE INTO link
  (pnd, target, url) VALUES (?, ?, ?)
EOT

if ($opts{cache}) {
    $dbh = init_cache_db($opts{cache});
    $sth_select = $dbh->prepare($sql_select);
    $sth_insert = $dbh->prepare($sql_insert);
}

my $ua = LWP::UserAgent->new(
    'Mozilla/5.0 (compatible; HistVV; http://histvv.uni-leipzig.de)',
    'histvv@gmail.com' );

load_beacon($beacon, $ua);

my $doc = XML::LibXML->new->parse_file($dozenten);
my $xc = XML::LibXML::XPathContext->new($doc);
$xc->registerNs('v', $Histvv::XMLNS);

if ( $opts{'follow-refresh'} ) {
    $ua->add_handler(
        response_redirect => sub {
            my ( $response, $ua, $h ) = @_;
            my $refresh = $response->header('Refresh');
            return 0 unless $refresh;
            if ( $refresh =~ /^[0-9]+ *; *url=(https?:\/\/.+) *$/i ) {
                my $url = $1;
                return HTTP::Request->new( HEAD => $url );
            }
            0;
        },
        'm_code' => 200
    );
}

my $last_req_time = 0;

$cli->say("Looking up matching PND numbers...");

foreach my $dozent ($xc->findnodes('/v:dozentenliste/v:dozent[v:pnd]')) {
    my $id = $dozent->getAttribute('xml:id');
    my ($pnd) = $dozent->getChildrenByTagName('pnd');
    $pnd = $pnd->textContent();

    $dozenten{$id}{elem} = $dozent;

    my @url_elems = $dozent->getChildrenByTagName('url');
    my %urls;
    $urls{ $_->textContent } = $_ for @url_elems;

    next unless $pnd{$pnd};

    $cli->debug("");
    $cli->chatter(" $pnd: $id");

    my $url = get_url($pnd);
    next unless $url;

    my $domain = URI->new($url)->authority;
    my $unescaped = uri_unescape($url);
    utf8::decode($unescaped);

    if ($urls{$url}) {
        $cli->debug("url already exists");
    } elsif ($urls{$unescaped}) {
        $cli->debug("unescaped url already exists");
    } elsif (my ($u) = grep URI->new($_)->authority eq $domain, keys %urls) {
        unless ($opts{noreplace}) {
            $cli->debug("updating url $u");
            my $elem = $urls{$u};
            $elem->removeChildNodes;
            $elem->appendTextNode($opts{urlescape} ? $url : $unescaped);
            $dozenten{$id}{old} = $u;
            $dozenten{$id}{new} = $opts{urlescape} ? $url : $unescaped;
        }
        else {
            $cli->debug("url for $domain already exists (--noreplace)");
        }
    } else {
        $cli->debug("creating new url element");
        my $elem = $doc->createElementNS($Histvv::XMLNS, "url");
        $elem->appendTextNode($opts{urlescape} ? $url : $unescaped);
        if (@url_elems && $opts{prepend}) {
            $cli->debug("  inserting before urls");
            $dozent->insertBefore($elem, $url_elems[0]);
        }
        elsif (@url_elems) {
            $cli->debug("  inserting after urls");
            $dozent->insertAfter($elem, $url_elems[$#url_elems]);
        } elsif (my ($bild) = $dozent->getChildrenByTagName('bild')) {
            $cli->debug("  inserting before bild");
            $dozent->insertBefore($elem, $bild)
        } else {
            $cli->debug("  appending to dozent");
            $dozent->appendChild($elem);
        }
        $dozenten{$id}{new} = $unescaped;
    }
}

if ($opts{list} || !$opts{out}) {
    binmode STDOUT, ":utf8";
    $cli->chatter("\nNew links:");
    foreach my $id (sort keys %dozenten) {
        my $new = $dozenten{$id}{new} || next;
        $cli->say("$id: $new");
    }
}

if ($opts{out}) {
    open(my $fh, '>', $opts{out}) or die "Cannot open out file: $!\n";
    print $fh $doc->toString(0);
    close $fh;
}

#
# fetch URL or retrieve cached result
#
sub get_url {
    my $pnd = shift;
    (my $target = $url_template) =~ s/(?:\{ID\}|\$PND)/$pnd/;

    if ($opts{passthru}) {
        $cli->debug("passing through $target");
        return $target;
    }

    my $url;

    if ($dbh) {
        $cli->debug("looking up $target in cache");
        $sth_select->execute($target);
        my $row = $sth_select->fetchrow_hashref;
        if ($row && $row->{age} < $ttl) {
            $url = $row->{url};
            $cli->debug("found $url, age: $row->{age}s");
        }
    }

    unless ($url || $opts{offline}) {
        # Here we perform a HEAD request for the target URL, expecting
        # to be redirected to a specific URL related to the currently
        # processed PND number. This URL we obtain from the (final)
        # request of the response object.
        #
        # We only accept a URL as a valid result when
        #  1. we get an OK response
        #  2. it differs from the original target URL
        #  3. it passes check_url()

        # delay subsequent requests to play nicely
        my $sleep = $opts{delay} - (time - $last_req_time);
        if ($sleep > 0) {
            $cli->debug("waiting $sleep seconds...");
            sleep $sleep;
        }

        my $method = $opts{'follow-refresh'} ? 'GET' : 'HEAD';
        $cli->debug("fetching [$method] $target...");
        my $request = HTTP::Request->new($method => $target);
        my $response = $ua->request($request);
        $last_req_time = time;
        $cli->debug("response: " . $response->code);
        my $uri = $response->request->uri;
        if ($response->code == 200 && $uri ne $target && check_url($uri)) {
            $url = $uri . "";
            $cli->debug("URL: $url");
        }
        if ($url && $dbh) {
            $cli->debug("adding $url to cache");
            $sth_insert->execute($pnd, $target, $url);
        }
    }
    $url;
}

#
# Special case URL checks. This is necessary to catch invalid
# responses which cannot be detected otherwise.
#
sub check_url {
    my $uri = shift;
    # professorenkatalog redirects to the below URL when they don't
    # recognize a PND number.
    my $cpl = "http://www.uni-leipzig.de/unigeschichte/professorenkatalog/leipzig/";
    return 0
      if $uri eq $cpl || ( $uri =~ /^$cpl/ && $uri =~ /\/[0-9]{8}X\/$/);
    1;
}

#
# populate %pnd from beacon file
#
sub load_beacon {
    my $file = shift;
    my $ua = shift;

    my $tmp;

    if ( $file =~ /^https?:\/\// ) {
        my $url = $file;
        $cli->debug("Fetching beacon $url");
        my $r = $ua->get($url);
        die "Cannot get beacon file from $url\n" unless $r->is_success;
        $tmp = File::Temp->new(
            UNLINK   => 1,
            TMPDIR   => 1,
            TEMPLATE => 'pnd-beacon-XXXXXX',
            SUFFIX   => '.txt'
        );
        $file = $tmp->filename;
        $cli->debug("Saving data to $file");
        print $tmp $r->content;
    }

    open BEACON, $file;
    while (<BEACON>) {
        chomp;
        if (/^#TARGET:\s+([^\s]+)/) {
            $url_template = $1;
        }
        elsif (/^([0-9]{8}[0-9X])\s*$/) {
            $pnd{$1}++;
        }
    }
    close BEACON;
}

#
# open and create cache database
#
sub init_cache_db  {
    my $dbfile = shift;
    my $exists = -f $dbfile;
    my $dbh =
      DBI->connect( "dbi:SQLite:dbname=$dbfile", "", "",
        { AutoCommit => 1, PrintError => 1 } )
      or die "$DBI::errstr";

    unless ($exists) {
        $cli->debug("creating link table...");
        $dbh->do($sql_create) or die "$DBI::errstr\n";
    }

    unless ( check_db($dbh) ) {
        $dbh->disconnect;
        $cli->error("$dbfile doesn't seem to be a cache database");
    }

    return $dbh;
}

sub check_db {
    my $dbh = shift;
    my $sth = $dbh->table_info(undef, '%', '%', 'TABLE') or die "$DBI::errstr\n";
    #my $sth = $dbh->prepare('PRAGMA table_info(link)') or die "$DBI::errstr\n";
    $sth->execute;
    my @rows;
    while (my $r = $sth->fetchrow_hashref) {
        push @rows, $r;
    }
    @rows == 1 && $rows[0]->{TABLE_NAME} eq 'link';
}

__END__

=head1 NAME

histvv-pnd-link - cross reference dozenten.xml using PND-Beacon files

=head1 SYNOPSIS

  histvv-pnd-link [--list | --write] dozenten.xml pnd.txt
  histvv-pnd-link --help | --man

=head1 DESCRIPTION

I<histvv-pnd-link> expects two arguments, the path to a HistVV
C<dozentenliste> and a PND-Beacon file. Using the PND numbers in
C<dozentenliste> it determines corresponding URLs from the beacon
file.

=head1 OPTIONS

=over

=item B<--list>, B<-l>

List the new links to be added to  C<dozentenliste>.

=item B<--prepend>, B<-p>

Prepend new links to the list of already existing ones.

=item B<--out>, B<-o> file

File to write the modified C<dozentenliste> to.

=item B<--cache>, B<-c> file

Path to the link cache database.

=item B<--ttl>, B<-t>

Time in minutes after which cached URLs should be refetched. Default:
1440 min = 1 day.

=item B<--delay>, B<-D>

Minimum time in seconds between requests to resolve a target URL.
Default: 20 seconds.

=item B<--offline>

Do not make any HTTP requests. This option requires B<--cache>.

=item B<--urlescape>, B<-E>

By default URLs are unescaped for better readability when adding links
to C<dozentenliste>. With this option, however, URLs will be escaped.

=item B<--noreplace>, B<-R>

Don't replace existing links. By default existing links from the
target domain are replaced when the path of the current PND link
differs.

=item B<--follow-refresh>

Follow a meta refresh specified in the target document. Some sites
(e.g. http://saebi.isgv.de) use an HTML meta element with the
http-equiv parameter set to "refresh" to redirect their beacon target
pages to a more appropriate URL. With B<--follow-refresh> that URL
will be requested and on success used for linking.

Note: In order to read the meta element a GET instead of a HEAD
request will be used to request the original beacon target page. This
may generate significantly more network traffic.

=item B<--passthru>, B<-P>

Use the URL as constructed from TARGET template of the PND beacon file
without attempting to fetch it and obtain a possible redirect. This is
useful if the canonical URL is the same as advertized in the PND
beacon file.

=item B<--verbose>, B<-v>

Verbose feedback.

=item B<--help>, B<-h>

Display short help message and exit. If used together with B<-v> the
entire manpage will be displayed.

=item B<--man>

Display manpage and exit. This is equivalent to B<-h> B<-v>.

=back

=head1 SEE ALSO

L<Histvv>

=head1 AUTHOR

Carsten Milling, C<< <cmil at hashtable.de> >>

=head1 COPYRIGHT & LICENSE

Copyright 2011 Carsten Milling, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
