#!/usr/bin/perl

use strict;
use warnings;

use Histvv;
use Histvv::CLI;
use XML::LibXML;
use XML::LibXML::XPathContext;
use File::Basename;
use Text::Wrap ();

my $cli  = Histvv::CLI->new();
my %opts = $cli->get_opts(
    'list|l'            => 0,
    'all|a'             => 0,
    'data|D=s'          => undef,
    'name|n=s'          => undef,
    'match|m=s'         => undef,
    'xpath|x=s'         => undef,
    'ref|r=s'           => undef,
    'min_age|min-age=i' => 0
);

$cli->error("You need to specify a name and/or xpath expression!")
  unless ( $opts{name} || $opts{xpath} || $opts{data} );

$cli->error("The value given for ref is not a valid ID!")
   if ( $opts{ref} && $opts{ref} !~ /^[a-z][-_a-z]+$/ );

# create XML parser
my $xp = XML::LibXML->new();
binmode STDOUT, ":utf8";

# dont buffer output
$| = 1;

if ( $opts{data} ) {
    my $doc = $xp->parse_file( $opts{data} );
    my $xc  = XML::LibXML::XPathContext->new($doc);
    $xc->registerNs( 'v', $Histvv::XMLNS );

    my $doz_xpath = '/v:dozentenliste/v:dozent[@xml:id and @eindeutig="ja"]';
    my @dozenten  = $xc->findnodes($doz_xpath);

    foreach my $d (@dozenten) {
        my $id   = $xc->findvalue( '@xml:id',           $d );

        next if $opts{match} && $id !~/$opts{match}/;

        my $name = $xc->findvalue( 'v:name/v:nachname', $d );
        my $von  = $xc->findvalue( '@von',              $d ) || '';
        my $bis  = $xc->findvalue( '@bis',              $d ) || '';

        my $born = $xc->findvalue( 'v:geboren/v:jahr',   $d ) || '';
        my $died = $xc->findvalue( 'v:gestorben/v:jahr', $d ) || '';
        my $info = $xc->findvalue( 'normalize-space(v:absatz[1])', $d ) || '';

        # constructing XPath expressions for semester limits
        my @xpath;
        if ( $von =~ /^([0-9]{4})([ws])$/ ) {
            my $jahr = $1;
            my $sem  = $2;
            my $path;
            if ( $sem eq 's' ) {
                $path = "/v:vv/v:kopf/v:beginn/v:jahr >= $jahr";
            }
            else {
                $path = "(/v:vv/v:kopf/v:beginn/v:jahr > $jahr";
                $path .= " or ";
                $path .= "(/v:vv/v:kopf/v:beginn/v:jahr = $jahr";
                $path .= " and /v:vv/v:kopf/v:semester = 'Winter'))";
            }
            push @xpath, $path;
        }
        elsif (my $jahr = $xc->findvalue( 'v:geboren/v:jahr', $d )) {
            $jahr += $opts{min_age};
            push @xpath, "/v:vv/v:kopf/v:beginn/v:jahr > $jahr";
        }

        if ( $bis =~ /^([0-9]{4})([ws])$/ ) {
            my $jahr = $1;
            my $sem  = $2;
            my $path;
            if ( $sem eq 'w' ) {
                $path = "/v:vv/v:kopf/v:beginn/v:jahr <= $jahr";
            }
            else {
                $path = "(/v:vv/v:kopf/v:beginn/v:jahr < $jahr";
                $path .= " or ";
                $path .= "(/v:vv/v:kopf/v:beginn/v:jahr = $jahr";
                $path .= " and /v:vv/v:kopf/v:semester = 'Sommer'))";
            }
            push @xpath, $path;
        }
        elsif (my $jahr = $xc->findvalue( 'v:gestorben/v:jahr', $d )) {
            push @xpath, "/v:vv/v:kopf/v:beginn/v:jahr <= $jahr";
        }

        my $xpath = join ' and ', @xpath;

        my $label = "$name ($id)";
        $label   .= "  $born-$died" if $born || $died;
        $label   .= "  [$von-$bis]" if $von || $bis;

        $cli->chatter( $label );
        $cli->chatter( $info ) if $opts{verbose} > 1 && $info;
        $cli->chatter( "-" x length($label) );

        set_refs(
            name  => $name,
            xpath => $xpath,
            ref   => $opts{list} ? undef : $id
        );

    }

}
else {
    set_refs(
        name  => $opts{name},
        xpath => $opts{xpath},
        ref   => $opts{ref}
    );
}

sub set_refs {
    my %args = @_;

    ## contructing the XPath expression
    #
    # first we create a predicate expression from "name" and "xpath"
    # parameters to match the "dozent" element
    my @predicate;
    if ( $args{name} ) {
        my $name = $args{name};

        # escape and normalize space
        $name =~ s/"/&quot;/g;
        $name =~ s/\s+/ /g;
        $name =~ s/(^ +| +$)//g;
        push @predicate,
          $name =~ / /
          ? qq{normalize-space(v:nachname)="$name"}
          : qq{v:nachname="$name"};
    }
    push( @predicate, "($args{xpath})" ) if $args{xpath};
    my $predicate = join( ' and ', @predicate );

    # now we use this predicate expression to construct separate paths to
    # the "dozent" and "ders" elements
    my $doz_path  = "//v:dozent[ $predicate ]";
    my $ders_path = "//v:ders[ preceding::v:dozent[1][$predicate] ]";

    # putting it all together and adding a filter to ignore elements that
    # already carry the "ref" attribute
    my $xpath = "($doz_path | $ders_path)";
    $xpath .= '[/v:vv/v:kopf/v:status/@komplett="ja"]';
    $xpath .= '[not(@ref)]' unless $opts{all};

    $Text::Wrap::columns = 80;

    foreach my $file (@ARGV) {
        my $doc = $xp->parse_file($file);

        my $xc = XML::LibXML::XPathContext->new($doc);
        $xc->registerNs( 'v', $Histvv::XMLNS );

        my $cnt      = 0;                        # counting set attibutes
        my $fname    = basename $file;
        my @dozenten = $xc->findnodes($xpath);
        $cli->say($fname) if @dozenten > 0 && @ARGV > 1;

        foreach my $d (@dozenten) {
            my $dozent = $xc->findvalue( 'normalize-space(.)', $d );

            # determine page number
            my $page = $xc->findvalue( 'preceding::v:seite[1]/@nr', $d )
              || $xc->findvalue( 'preceding::v:seite[1]', $d )
              || '';

            if ( $opts{verbose} ) {
                $cli->say( "S. $page: ", 1 );

                my $txt;
                if ( $opts{verbose} > 1 ) {
                    $txt = $xc->findvalue( 'normalize-space(..)', $d );
                    $cli->say( Text::Wrap::wrap( "", "  ", $txt ) );
                }
                else {
                    $txt = $xc->findvalue( 'normalize-space(../v:thema)', $d )
                      || $xc->findvalue(
                        'normalize-space('
                          . 'concat("[", ancestor::v:sachgruppe[1]/v:titel, "]")'
                          . ')',
                        $d
                      );
                    $cli->say(
                        Text::Wrap::wrap( "", "  ", "$dozent -- $txt" ) );
                }
            }
            else {
                $cli->say($dozent);
            }

            # setting ref attribute
            if ( $args{ref} ) {
                $d->setAttribute( 'ref', $args{ref} );
                $cnt++;
            }
        }

        if ($cnt) {
            $cli->say("writing to $file");
            open F, ">$file" or die $!;
            print F $doc->toString(0);
            close F;
        }

        $cli->say('') if @dozenten > 0 && @ARGV > 1;
    }
}

__END__

=head1 NAME

histvv-dozenten - manipulate C<dozent> elements Histvv documents

=head1 SYNOPSIS

  histvv-dozenten  --list -n lastname [-x xpath] file.xml ...
  histvv-dozenten  --ref id -n lastname [-x xpath] file.xml ...
  histvv-dozenten  --data dozenten.xml [--match regex] file.xml ...
  histvv-dozenten --help | --man

=head1 DESCRIPTION

I<histvv-dozenten> lists or manipulates those C<dozent> elements in
the passed file(s) which are matched by the B<--name> and/or the
B<--xpath> option.

=head2 Using XPath

In addition or as an alternative to the B<--name> option an XPath
expression can be used to select the C<dozent> elements to manipulate.
This expression is expected to be suitable as a predicate expression
in the context of a C<dozent> element:

  v:dozent[ EXPR ]

Note that the expression may get combined with other expressions by an
C<and> operator, e.g.:

  v:dozent[ not(@ref) and EXPR ]

When refering to elements in your XPath expression remember to specify
the B<namespace> appropriately. For the Histvv namespace the prefix
C<v> is registered by default.

=head1 OPTIONS

=over

=item B<--name>, B<-n>

The last name, i.e. the value of the C<nachname> child element of
C<dozent> to manipulate.

=item B<--xpath>, B<-x>

An XPath predicate expression to select the C<dozent> element(s) to
manipulate (see L</Using XPath>).

=item B<--ref>, B<-r>

The value of the C<ref> attribute for the selected C<dozent> elements.

=item B<--all>, B<-a>

Display or manipulate all C<dozent> elements matching the name and/or
XPath expression regardless whether they already carry a C<ref>
attribute or not. By default only those elements without a C<ref>
attribute are considered.

=item B<--data>, B<-D>

Path to a C<dozentenliste> document. If specified I<histvv-dozenten>
will use the names marked as unique and their corresponding IDs to set
the ref attributes in the given Histvv files respectively.

=item B<--match>, B<-m>

A regular expression to filter IDs of C<dozent> entries. When used
with B<-D> only entries with a matching ID will be processed.

=item B<--min-age>

The number of years to add to the year of birth of a C<dozent> to
limit the range of semesters to process. The default is 0; a sensible
value would be 18.

=item B<--list>, B<-l>

Print the string cotent of the C<dozent> elements matching the name
and/or XPath expression to standard output.  With B<-v>, a sibling
C<thema> element will be displayed if there is one. If B<-v> is used
more than once the content of the entire parent element is displayed.

=item B<--verbose>, B<-v>

Display more detail in element listing.

=item B<--help>, B<-h>

Display short help message and exit. If used together with B<-v> the
entire manpage will be displayed.

=item B<--man>

Display manpage and exit. This is equivalent to B<-h> B<-v>.

=back

=head1 AUTHOR

Carsten Milling, C<< <cmil at hashtable.de> >>

=head1 COPYRIGHT & LICENSE

Copyright 2008 Carsten Milling, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut
